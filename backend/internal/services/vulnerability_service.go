package services

import (
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/cyops/cyops-backend/internal/models"
	"github.com/cyops/cyops-backend/pkg/database"
	"github.com/cyops/cyops-backend/pkg/utils"
	"gorm.io/gorm"
)

// VulnerabilityService handles vulnerability-related operations
type VulnerabilityService struct {
	db           *gorm.DB
	assetService *AssetService
}

// NewVulnerabilityService creates a new vulnerability service
func NewVulnerabilityService() *VulnerabilityService {
	db := database.GetDB()
	return &VulnerabilityService{
		db:           db,
		assetService: NewAssetService(db),
	}
}

// NewAffectedSystemData represents data for creating a new affected system
type NewAffectedSystemData struct {
	Hostname    string
	IPAddress   string
	SystemType  models.SystemType
	Environment models.Environment
}

// CreateVulnerabilityRequest represents a vulnerability creation request
type CreateVulnerabilityRequest struct {
	Title                     string
	Description               string
	Severity                  models.VulnerabilitySeverity
	CVSSScore                 *float64
	CVSSVector                string
	CVEID                     string
	Source                    string
	DiscoveryDate             time.Time
	ImpactAssessment          string
	StepsToReproduce          string
	MitigationRecommendations string
	AssignedToID              *uuid.UUID
	AffectedSystemIDs         []uuid.UUID
	NewAffectedSystems        []NewAffectedSystemData // For auto-creation
}

// CreateVulnerabilityResponse represents the response after creating a vulnerability
type CreateVulnerabilityResponse struct {
	Vulnerability     *models.Vulnerability
	AutoCreatedAssets []AutoCreatedAsset
}

// AutoCreatedAsset represents an asset that was automatically created
type AutoCreatedAsset struct {
	ID        uuid.UUID `json:"id"`
	Hostname  string    `json:"hostname"`
	IPAddress string    `json:"ip_address"`
}

// CreateVulnerability creates a new vulnerability
func (s *VulnerabilityService) CreateVulnerability(req CreateVulnerabilityRequest, createdByID uuid.UUID) (*models.Vulnerability, error) {
	// Create vulnerability
	vulnerability := &models.Vulnerability{
		Title:                     req.Title,
		Description:               req.Description,
		Severity:                  req.Severity,
		CVSSScore:                 req.CVSSScore,
		CVSSVector:                req.CVSSVector,
		CVEID:                     req.CVEID,
		Status:                    models.StatusOpen,
		Source:                    req.Source,
		DiscoveryDate:             req.DiscoveryDate,
		ImpactAssessment:          req.ImpactAssessment,
		StepsToReproduce:          req.StepsToReproduce,
		MitigationRecommendations: req.MitigationRecommendations,
		CreatedByID:               createdByID,
		AssignedToID:              req.AssignedToID,
	}

	// Start transaction
	tx := s.db.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Save vulnerability
	if err := tx.Create(vulnerability).Error; err != nil {
		tx.Rollback()
		utils.Logger.Error().Err(err).Msg("Failed to create vulnerability")
		return nil, fmt.Errorf("failed to create vulnerability: %w", err)
	}

	// Associate existing affected systems if provided
	if len(req.AffectedSystemIDs) > 0 {
		var affectedSystems []models.AffectedSystem
		if err := tx.Where("id IN ?", req.AffectedSystemIDs).Find(&affectedSystems).Error; err != nil {
			tx.Rollback()
			utils.Logger.Error().Err(err).Msg("Failed to find affected systems")
			return nil, fmt.Errorf("failed to find affected systems: %w", err)
		}

		if err := tx.Model(vulnerability).Association("AffectedSystems").Append(&affectedSystems); err != nil {
			tx.Rollback()
			utils.Logger.Error().Err(err).Msg("Failed to associate affected systems")
			return nil, fmt.Errorf("failed to associate affected systems: %w", err)
		}
	}

	// Process new affected systems (auto-creation)
	// Note: We'll handle this in CreateVulnerabilityWithAutoAssets for Phase 4
	// This method maintains backward compatibility

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to commit transaction")
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Load associations for response
	if err := s.db.Preload("CreatedBy").Preload("AssignedTo").Preload("AffectedSystems").First(vulnerability, vulnerability.ID).Error; err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to load vulnerability with associations")
		return nil, fmt.Errorf("failed to load vulnerability: %w", err)
	}

	return vulnerability, nil
}

// CreateVulnerabilityWithAutoAssets creates a vulnerability with automatic asset creation
// This method supports both existing system IDs and new system data
func (s *VulnerabilityService) CreateVulnerabilityWithAutoAssets(req CreateVulnerabilityRequest, createdByID uuid.UUID) (*CreateVulnerabilityResponse, error) {
	// Create vulnerability
	vulnerability := &models.Vulnerability{
		Title:                     req.Title,
		Description:               req.Description,
		Severity:                  req.Severity,
		CVSSScore:                 req.CVSSScore,
		CVSSVector:                req.CVSSVector,
		CVEID:                     req.CVEID,
		Status:                    models.StatusOpen,
		Source:                    req.Source,
		DiscoveryDate:             req.DiscoveryDate,
		ImpactAssessment:          req.ImpactAssessment,
		StepsToReproduce:          req.StepsToReproduce,
		MitigationRecommendations: req.MitigationRecommendations,
		CreatedByID:               createdByID,
		AssignedToID:              req.AssignedToID,
	}

	// Start transaction
	tx := s.db.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Save vulnerability
	if err := tx.Create(vulnerability).Error; err != nil {
		tx.Rollback()
		utils.Logger.Error().Err(err).Msg("Failed to create vulnerability")
		return nil, fmt.Errorf("failed to create vulnerability: %w", err)
	}

	// Track auto-created assets
	autoCreatedAssets := []AutoCreatedAsset{}

	// Associate existing affected systems if provided
	if len(req.AffectedSystemIDs) > 0 {
		var affectedSystems []models.AffectedSystem
		if err := tx.Where("id IN ?", req.AffectedSystemIDs).Find(&affectedSystems).Error; err != nil {
			tx.Rollback()
			utils.Logger.Error().Err(err).Msg("Failed to find affected systems")
			return nil, fmt.Errorf("failed to find affected systems: %w", err)
		}

		if err := tx.Model(vulnerability).Association("AffectedSystems").Append(&affectedSystems); err != nil {
			tx.Rollback()
			utils.Logger.Error().Err(err).Msg("Failed to associate affected systems")
			return nil, fmt.Errorf("failed to associate affected systems: %w", err)
		}
	}

	// Process new affected systems (auto-creation)
	if len(req.NewAffectedSystems) > 0 {
		// Create a temporary AssetService with the transaction
		tempAssetService := &AssetService{db: tx}

		for _, newSystem := range req.NewAffectedSystems {
			// Call FindOrCreate for each new system
			asset, wasCreated, err := tempAssetService.FindOrCreate(
				newSystem.Hostname,
				newSystem.IPAddress,
				newSystem.SystemType,
				newSystem.Environment,
			)

			if err != nil {
				tx.Rollback()
				utils.Logger.Error().Err(err).
					Str("hostname", newSystem.Hostname).
					Str("ip", newSystem.IPAddress).
					Msg("Failed to find or create asset")
				return nil, fmt.Errorf("failed to find or create asset: %w", err)
			}

			// Track if asset was created
			if wasCreated {
				autoCreatedAssets = append(autoCreatedAssets, AutoCreatedAsset{
					ID:        asset.ID,
					Hostname:  asset.Hostname,
					IPAddress: asset.IPAddress,
				})

				utils.Logger.Info().
					Str("asset_id", asset.ID.String()).
					Str("hostname", asset.Hostname).
					Str("vulnerability_id", vulnerability.ID.String()).
					Msg("Auto-created asset from vulnerability")
			}

			// Associate the asset with the vulnerability
			if err := tx.Model(vulnerability).Association("AffectedSystems").Append(asset); err != nil {
				tx.Rollback()
				utils.Logger.Error().Err(err).Msg("Failed to associate auto-created asset")
				return nil, fmt.Errorf("failed to associate auto-created asset: %w", err)
			}
		}
	}

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to commit transaction")
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Load associations for response
	if err := s.db.Preload("CreatedBy").Preload("AssignedTo").Preload("AffectedSystems").First(vulnerability, vulnerability.ID).Error; err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to load vulnerability with associations")
		return nil, fmt.Errorf("failed to load vulnerability: %w", err)
	}

	return &CreateVulnerabilityResponse{
		Vulnerability:     vulnerability,
		AutoCreatedAssets: autoCreatedAssets,
	}, nil
}

// ListVulnerabilitiesRequest represents a list request with filters
type ListVulnerabilitiesRequest struct {
	Page       int
	Limit      int
	Severity   []models.VulnerabilitySeverity
	Status     []models.VulnerabilityStatus
	Search     string
	AssignedTo *uuid.UUID
	CreatedBy  *uuid.UUID
	AssetID    *uuid.UUID
	SortBy     string
	SortOrder  string
}

// ListVulnerabilities returns a paginated list of vulnerabilities
func (s *VulnerabilityService) ListVulnerabilities(req ListVulnerabilitiesRequest) ([]models.Vulnerability, int64, error) {
	var vulnerabilities []models.Vulnerability
	var total int64

	// Build query
	query := s.db.Model(&models.Vulnerability{})

	// Apply filters
	if len(req.Severity) > 0 {
		query = query.Where("severity IN ?", req.Severity)
	}

	if len(req.Status) > 0 {
		query = query.Where("status IN ?", req.Status)
	}

	if req.Search != "" {
		searchTerm := "%" + req.Search + "%"
		query = query.Where("title ILIKE ? OR description ILIKE ? OR cve_id ILIKE ?", searchTerm, searchTerm, searchTerm)
	}

	if req.AssignedTo != nil {
		query = query.Where("assigned_to_id = ?", *req.AssignedTo)
	}

	if req.CreatedBy != nil {
		query = query.Where("created_by_id = ?", *req.CreatedBy)
	}

	// Filter by asset/affected system
	if req.AssetID != nil {
		query = query.Joins("JOIN vulnerability_affected_systems ON vulnerability_affected_systems.vulnerability_id = vulnerabilities.id").
			Where("vulnerability_affected_systems.affected_system_id = ?", *req.AssetID)
	}

	// Count total
	if err := query.Count(&total).Error; err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to count vulnerabilities")
		return nil, 0, fmt.Errorf("failed to count vulnerabilities: %w", err)
	}

	// Apply sorting
	sortBy := "created_at"
	if req.SortBy != "" {
		sortBy = req.SortBy
	}
	sortOrder := "DESC"
	if req.SortOrder != "" {
		sortOrder = req.SortOrder
	}
	query = query.Order(fmt.Sprintf("%s %s", sortBy, sortOrder))

	// Apply pagination
	page := 1
	if req.Page > 0 {
		page = req.Page
	}
	limit := 50
	if req.Limit > 0 && req.Limit <= 100 {
		limit = req.Limit
	}
	offset := (page - 1) * limit

	// Fetch vulnerabilities with associations
	if err := query.
		Preload("CreatedBy").
		Preload("AssignedTo").
		Offset(offset).
		Limit(limit).
		Find(&vulnerabilities).Error; err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to list vulnerabilities")
		return nil, 0, fmt.Errorf("failed to list vulnerabilities: %w", err)
	}

	return vulnerabilities, total, nil
}

// GetVulnerabilityByID retrieves a vulnerability by ID with all associations
func (s *VulnerabilityService) GetVulnerabilityByID(id uuid.UUID) (*models.Vulnerability, error) {
	var vulnerability models.Vulnerability

	if err := s.db.
		Preload("CreatedBy").
		Preload("AssignedTo").
		Preload("AffectedSystems").
		Preload("StatusHistory", func(db *gorm.DB) *gorm.DB {
			return db.Order("changed_at DESC").Preload("ChangedBy")
		}).
		First(&vulnerability, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("vulnerability not found")
		}
		utils.Logger.Error().Err(err).Str("id", id.String()).Msg("Failed to get vulnerability")
		return nil, fmt.Errorf("failed to get vulnerability: %w", err)
	}

	return &vulnerability, nil
}

// UpdateVulnerabilityRequest represents a vulnerability update request
type UpdateVulnerabilityRequest struct {
	Title                     *string
	Description               *string
	Severity                  *models.VulnerabilitySeverity
	CVSSScore                 *float64
	CVSSVector                *string
	CVEID                     *string
	RemediationNotes          *string
	ImpactAssessment          *string
	StepsToReproduce          *string
	MitigationRecommendations *string
}

// UpdateVulnerability updates a vulnerability
func (s *VulnerabilityService) UpdateVulnerability(id uuid.UUID, req UpdateVulnerabilityRequest) (*models.Vulnerability, error) {
	var vulnerability models.Vulnerability

	// Get existing vulnerability
	if err := s.db.First(&vulnerability, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("vulnerability not found")
		}
		return nil, fmt.Errorf("failed to get vulnerability: %w", err)
	}

	// Update fields if provided
	updates := make(map[string]interface{})

	if req.Title != nil {
		updates["title"] = *req.Title
	}
	if req.Description != nil {
		updates["description"] = *req.Description
	}
	if req.Severity != nil {
		updates["severity"] = *req.Severity
	}
	if req.CVSSScore != nil {
		updates["cvss_score"] = *req.CVSSScore
	}
	if req.CVSSVector != nil {
		updates["cvss_vector"] = *req.CVSSVector
	}
	if req.CVEID != nil {
		updates["cve_id"] = *req.CVEID
	}
	if req.RemediationNotes != nil {
		updates["remediation_notes"] = *req.RemediationNotes
	}
	if req.ImpactAssessment != nil {
		updates["impact_assessment"] = *req.ImpactAssessment
	}
	if req.StepsToReproduce != nil {
		updates["steps_to_reproduce"] = *req.StepsToReproduce
	}
	if req.MitigationRecommendations != nil {
		updates["mitigation_recommendations"] = *req.MitigationRecommendations
	}

	// Perform update
	if err := s.db.Model(&vulnerability).Updates(updates).Error; err != nil {
		utils.Logger.Error().Err(err).Str("id", id.String()).Msg("Failed to update vulnerability")
		return nil, fmt.Errorf("failed to update vulnerability: %w", err)
	}

	// Reload with associations
	if err := s.db.Preload("CreatedBy").Preload("AssignedTo").Preload("AffectedSystems").First(&vulnerability, id).Error; err != nil {
		return nil, fmt.Errorf("failed to reload vulnerability: %w", err)
	}

	utils.Logger.Info().
		Str("vulnerability_id", id.String()).
		Msg("Vulnerability updated successfully")

	return &vulnerability, nil
}

// UpdateVulnerabilityStatus updates the status of a vulnerability and creates history entry
func (s *VulnerabilityService) UpdateVulnerabilityStatus(id uuid.UUID, newStatus models.VulnerabilityStatus, notes string, changedByID uuid.UUID) (*models.Vulnerability, error) {
	var vulnerability models.Vulnerability

	// Start transaction
	tx := s.db.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Get existing vulnerability
	if err := tx.First(&vulnerability, id).Error; err != nil {
		tx.Rollback()
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("vulnerability not found")
		}
		return nil, fmt.Errorf("failed to get vulnerability: %w", err)
	}

	// Check if status is actually changing
	if vulnerability.Status == newStatus {
		tx.Rollback()
		return nil, fmt.Errorf("vulnerability is already in status: %s", newStatus)
	}

	oldStatus := vulnerability.Status

	// Create status history entry
	historyEntry := &models.VulnerabilityStatusHistory{
		VulnerabilityID: id,
		OldStatus:       oldStatus,
		NewStatus:       newStatus,
		Notes:           notes,
		ChangedByID:     changedByID,
		ChangedAt:       time.Now(),
	}

	if err := tx.Create(historyEntry).Error; err != nil {
		tx.Rollback()
		utils.Logger.Error().Err(err).Msg("Failed to create status history")
		return nil, fmt.Errorf("failed to create status history: %w", err)
	}

	// Update vulnerability status
	if err := tx.Model(&vulnerability).Update("status", newStatus).Error; err != nil {
		tx.Rollback()
		utils.Logger.Error().Err(err).Msg("Failed to update vulnerability status")
		return nil, fmt.Errorf("failed to update vulnerability status: %w", err)
	}

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to commit transaction")
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Reload with associations
	if err := s.db.Preload("CreatedBy").Preload("AssignedTo").First(&vulnerability, id).Error; err != nil {
		return nil, fmt.Errorf("failed to reload vulnerability: %w", err)
	}

	utils.Logger.Info().
		Str("vulnerability_id", id.String()).
		Str("old_status", string(oldStatus)).
		Str("new_status", string(newStatus)).
		Str("changed_by", changedByID.String()).
		Msg("Vulnerability status updated successfully")

	return &vulnerability, nil
}

// AssignVulnerability assigns a vulnerability to a user
func (s *VulnerabilityService) AssignVulnerability(id uuid.UUID, assignedToID *uuid.UUID) (*models.Vulnerability, error) {
	var vulnerability models.Vulnerability

	// Get existing vulnerability
	if err := s.db.First(&vulnerability, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("vulnerability not found")
		}
		return nil, fmt.Errorf("failed to get vulnerability: %w", err)
	}

	// Update assignment
	if err := s.db.Model(&vulnerability).Update("assigned_to_id", assignedToID).Error; err != nil {
		utils.Logger.Error().Err(err).Str("id", id.String()).Msg("Failed to assign vulnerability")
		return nil, fmt.Errorf("failed to assign vulnerability: %w", err)
	}

	// Reload with associations
	if err := s.db.Preload("CreatedBy").Preload("AssignedTo").First(&vulnerability, id).Error; err != nil {
		return nil, fmt.Errorf("failed to reload vulnerability: %w", err)
	}

	utils.Logger.Info().
		Str("vulnerability_id", id.String()).
		Str("assigned_to", func() string {
			if assignedToID != nil {
				return assignedToID.String()
			}
			return "unassigned"
		}()).
		Msg("Vulnerability assigned successfully")

	return &vulnerability, nil
}

// DeleteVulnerability soft deletes a vulnerability
func (s *VulnerabilityService) DeleteVulnerability(id uuid.UUID) error {
	result := s.db.Delete(&models.Vulnerability{}, id)
	if result.Error != nil {
		utils.Logger.Error().Err(result.Error).Str("id", id.String()).Msg("Failed to delete vulnerability")
		return fmt.Errorf("failed to delete vulnerability: %w", result.Error)
	}

	if result.RowsAffected == 0 {
		return fmt.Errorf("vulnerability not found")
	}

	utils.Logger.Info().
		Str("vulnerability_id", id.String()).
		Msg("Vulnerability deleted successfully")

	return nil
}

// VulnerabilityStats represents vulnerability statistics
type VulnerabilityStats struct {
	TotalCount         int64            `json:"total_count"`
	BySeverity         map[string]int64 `json:"by_severity"`
	ByStatus           map[string]int64 `json:"by_status"`
	RecentDiscoveries  int64            `json:"recent_discoveries"` // Last 30 days
	UnassignedCount    int64            `json:"unassigned_count"`
	CriticalUnresolved int64            `json:"critical_unresolved"`
}

// GetVulnerabilityStats returns statistics about vulnerabilities
func (s *VulnerabilityService) GetVulnerabilityStats() (*VulnerabilityStats, error) {
	stats := &VulnerabilityStats{
		BySeverity: make(map[string]int64),
		ByStatus:   make(map[string]int64),
	}

	// Total count
	if err := s.db.Model(&models.Vulnerability{}).Count(&stats.TotalCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count total vulnerabilities: %w", err)
	}

	// Count by severity
	var severityCounts []struct {
		Severity string
		Count    int64
	}
	if err := s.db.Model(&models.Vulnerability{}).
		Select("severity, COUNT(*) as count").
		Group("severity").
		Scan(&severityCounts).Error; err != nil {
		return nil, fmt.Errorf("failed to count vulnerabilities by severity: %w", err)
	}
	for _, sc := range severityCounts {
		stats.BySeverity[strings.ToLower(sc.Severity)] = sc.Count
	}

	// Count by status
	var statusCounts []struct {
		Status string
		Count  int64
	}
	if err := s.db.Model(&models.Vulnerability{}).
		Select("status, COUNT(*) as count").
		Group("status").
		Scan(&statusCounts).Error; err != nil {
		return nil, fmt.Errorf("failed to count vulnerabilities by status: %w", err)
	}
	for _, sc := range statusCounts {
		stats.ByStatus[strings.ToLower(sc.Status)] = sc.Count
	}

	// Recent discoveries (last 30 days)
	thirtyDaysAgo := time.Now().AddDate(0, 0, -30)
	if err := s.db.Model(&models.Vulnerability{}).
		Where("discovery_date >= ?", thirtyDaysAgo).
		Count(&stats.RecentDiscoveries).Error; err != nil {
		return nil, fmt.Errorf("failed to count recent discoveries: %w", err)
	}

	// Unassigned count
	if err := s.db.Model(&models.Vulnerability{}).
		Where("assigned_to_id IS NULL").
		Count(&stats.UnassignedCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count unassigned vulnerabilities: %w", err)
	}

	// Critical unresolved
	if err := s.db.Model(&models.Vulnerability{}).
		Where("severity = ? AND status NOT IN ?", models.SeverityCritical, []models.VulnerabilityStatus{
			models.StatusResolved,
			models.StatusVerified,
			models.StatusClosed,
		}).
		Count(&stats.CriticalUnresolved).Error; err != nil {
		return nil, fmt.Errorf("failed to count critical unresolved vulnerabilities: %w", err)
	}

	return stats, nil
}

// AddAffectedSystems adds affected systems to a vulnerability
func (s *VulnerabilityService) AddAffectedSystems(vulnerabilityID uuid.UUID, systemIDs []uuid.UUID) error {
	// Get the vulnerability first to ensure it exists
	var vulnerability models.Vulnerability
	if err := s.db.First(&vulnerability, vulnerabilityID).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return fmt.Errorf("vulnerability not found")
		}
		return fmt.Errorf("failed to get vulnerability: %w", err)
	}

	// Get the affected systems
	var systems []models.AffectedSystem
	if err := s.db.Where("id IN ?", systemIDs).Find(&systems).Error; err != nil {
		return fmt.Errorf("failed to find affected systems: %w", err)
	}

	// Check if we found all requested systems
	if len(systems) != len(systemIDs) {
		return fmt.Errorf("some affected systems not found")
	}

	// Add the systems to the vulnerability
	if err := s.db.Model(&vulnerability).Association("AffectedSystems").Append(&systems); err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to add affected systems to vulnerability")
		return fmt.Errorf("failed to add affected systems: %w", err)
	}

	utils.Logger.Info().
		Str("vulnerability_id", vulnerabilityID.String()).
		Int("system_count", len(systemIDs)).
		Msg("Affected systems added to vulnerability")

	return nil
}

// RemoveAffectedSystems removes affected systems from a vulnerability
func (s *VulnerabilityService) RemoveAffectedSystems(vulnerabilityID uuid.UUID, systemIDs []uuid.UUID) error {
	var vulnerability models.Vulnerability
	if err := s.db.First(&vulnerability, vulnerabilityID).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return fmt.Errorf("vulnerability not found")
		}
		return fmt.Errorf("failed to get vulnerability: %w", err)
	}

	var systems []models.AffectedSystem
	if err := s.db.Where("id IN ?", systemIDs).Find(&systems).Error; err != nil {
		return fmt.Errorf("failed to find affected systems: %w", err)
	}

	if err := s.db.Model(&vulnerability).Association("AffectedSystems").Delete(&systems); err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to remove affected systems from vulnerability")
		return fmt.Errorf("failed to remove affected systems: %w", err)
	}

	utils.Logger.Info().
		Str("vulnerability_id", vulnerabilityID.String()).
		Int("system_count", len(systemIDs)).
		Msg("Affected systems removed from vulnerability")

	return nil
}

// RemoveAffectedSystem removes a single affected system from a vulnerability
func (s *VulnerabilityService) RemoveAffectedSystem(vulnerabilityID uuid.UUID, systemID uuid.UUID) error {
	return s.RemoveAffectedSystems(vulnerabilityID, []uuid.UUID{systemID})
}

package services

import (
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/cyops/cyops-backend/internal/models"
	"gorm.io/gorm"
)

type VulnerabilityFindingService struct {
	db *gorm.DB
}

func NewVulnerabilityFindingService(db *gorm.DB) *VulnerabilityFindingService {
	return &VulnerabilityFindingService{db: db}
}

// CreateFinding creates a new vulnerability finding
func (s *VulnerabilityFindingService) CreateFinding(finding *models.VulnerabilityFinding) error {
	return s.db.Create(finding).Error
}

// CreateFindings creates multiple findings in a transaction
func (s *VulnerabilityFindingService) CreateFindings(findings []models.VulnerabilityFinding) error {
	if len(findings) == 0 {
		return nil
	}

	return s.db.Transaction(func(tx *gorm.DB) error {
		for i := range findings {
			if err := tx.Create(&findings[i]).Error; err != nil {
				return err
			}
		}
		return nil
	})
}

// GetFinding retrieves a finding by ID
func (s *VulnerabilityFindingService) GetFinding(id uuid.UUID) (*models.VulnerabilityFinding, error) {
	var finding models.VulnerabilityFinding
	err := s.db.
		Preload("Vulnerability").
		Preload("AffectedSystem").
		Preload("FixedByUser").
		Preload("CreatedByUser").
		Where("id = ?", id).
		First(&finding).Error

	if err != nil {
		return nil, err
	}
	return &finding, nil
}

// ListFindingsByVulnerability lists all findings for a specific vulnerability
func (s *VulnerabilityFindingService) ListFindingsByVulnerability(vulnerabilityID uuid.UUID, status *models.FindingStatus) ([]models.VulnerabilityFinding, error) {
	var findings []models.VulnerabilityFinding
	query := s.db.
		Preload("AffectedSystem").
		Preload("FixedByUser").
		Where("vulnerability_id = ?", vulnerabilityID)

	if status != nil {
		query = query.Where("status = ?", *status)
	}

	err := query.Order("last_seen DESC").Find(&findings).Error
	return findings, err
}

// ListFindingsBySystem lists all findings for a specific system
func (s *VulnerabilityFindingService) ListFindingsBySystem(systemID uuid.UUID, status *models.FindingStatus) ([]models.VulnerabilityFinding, error) {
	var findings []models.VulnerabilityFinding
	query := s.db.
		Preload("Vulnerability").
		Preload("FixedByUser").
		Where("affected_system_id = ?", systemID)

	if status != nil {
		query = query.Where("status = ?", *status)
	}

	err := query.Order("last_seen DESC").Find(&findings).Error
	return findings, err
}

// ListFindings lists findings with filters
func (s *VulnerabilityFindingService) ListFindings(filters map[string]interface{}, page, limit int) ([]models.VulnerabilityFinding, int64, error) {
	var findings []models.VulnerabilityFinding
	var total int64

	query := s.db.Model(&models.VulnerabilityFinding{}).
		Preload("Vulnerability").
		Preload("AffectedSystem").
		Preload("FixedByUser")

	// Apply filters
	if status, ok := filters["status"].(string); ok && status != "" {
		query = query.Where("status = ?", status)
	}
	if severity, ok := filters["severity"].(string); ok && severity != "" {
		query = query.Joins("JOIN vulnerabilities ON vulnerabilities.id = vulnerability_findings.vulnerability_id").
			Where("vulnerabilities.severity = ?", severity)
	}
	if pluginID, ok := filters["plugin_id"].(string); ok && pluginID != "" {
		query = query.Where("plugin_id = ?", pluginID)
	}

	// Count total
	if err := query.Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// Pagination and ordering
	offset := (page - 1) * limit

	// Order by fixed_at for FIXED status, otherwise last_seen
	orderBy := "last_seen DESC"
	if status, ok := filters["status"].(string); ok && status == "FIXED" {
		orderBy = "fixed_at DESC NULLS LAST"
	}

	err := query.Offset(offset).Limit(limit).Order(orderBy).Find(&findings).Error

	return findings, total, err
}

// MarkFindingFixed marks a finding as fixed
func (s *VulnerabilityFindingService) MarkFindingFixed(findingID, fixedBy uuid.UUID, notes string) error {
	return s.db.Transaction(func(tx *gorm.DB) error {
		// Get current finding
		var finding models.VulnerabilityFinding
		if err := tx.Where("id = ?", findingID).First(&finding).Error; err != nil {
			return err
		}

		now := time.Now()
		oldStatus := finding.Status

		// Update finding
		updates := map[string]interface{}{
			"status":   models.FindingStatusFixed,
			"fixed_at": now,
			"fixed_by": fixedBy,
		}
		if notes != "" {
			updates["fix_notes"] = notes
		}

		if err := tx.Model(&finding).Updates(updates).Error; err != nil {
			return err
		}

		// Create status history
		history := &models.FindingStatusHistory{
			FindingID:   findingID,
			OldStatus:   oldStatus,
			NewStatus:   models.FindingStatusFixed,
			Notes:       notes,
			ChangedByID: fixedBy,
			ChangedAt:   now,
		}

		return tx.Create(history).Error
	})
}

// MarkFindingVerified marks a finding as verified
func (s *VulnerabilityFindingService) MarkFindingVerified(findingID, verifiedBy uuid.UUID, notes string) error {
	return s.db.Transaction(func(tx *gorm.DB) error {
		var finding models.VulnerabilityFinding
		if err := tx.Where("id = ?", findingID).First(&finding).Error; err != nil {
			return err
		}

		now := time.Now()
		oldStatus := finding.Status

		updates := map[string]interface{}{
			"status":      models.FindingStatusVerified,
			"verified_at": now,
		}

		if err := tx.Model(&finding).Updates(updates).Error; err != nil {
			return err
		}

		history := &models.FindingStatusHistory{
			FindingID:   findingID,
			OldStatus:   oldStatus,
			NewStatus:   models.FindingStatusVerified,
			Notes:       notes,
			ChangedByID: verifiedBy,
			ChangedAt:   now,
		}

		return tx.Create(history).Error
	})
}

// AcceptRisk accepts the risk for a finding
func (s *VulnerabilityFindingService) AcceptRisk(findingID, acceptedBy uuid.UUID, reason string, expiresAt *time.Time) error {
	return s.db.Transaction(func(tx *gorm.DB) error {
		var finding models.VulnerabilityFinding
		if err := tx.Where("id = ?", findingID).First(&finding).Error; err != nil {
			return err
		}

		now := time.Now()
		oldStatus := finding.Status

		updates := map[string]interface{}{
			"status":             models.FindingStatusAccepted,
			"risk_accepted_by":   acceptedBy,
			"risk_accepted_at":   now,
			"acceptance_reason":  reason,
		}
		if expiresAt != nil {
			updates["expires_at"] = expiresAt
		}

		if err := tx.Model(&finding).Updates(updates).Error; err != nil {
			return err
		}

		history := &models.FindingStatusHistory{
			FindingID:   findingID,
			OldStatus:   oldStatus,
			NewStatus:   models.FindingStatusAccepted,
			Notes:       fmt.Sprintf("Risk accepted: %s", reason),
			ChangedByID: acceptedBy,
			ChangedAt:   now,
		}

		return tx.Create(history).Error
	})
}

// UpdateLastSeen updates the last_seen timestamp for a finding
func (s *VulnerabilityFindingService) UpdateLastSeen(findingID uuid.UUID) error {
	return s.db.Model(&models.VulnerabilityFinding{}).
		Where("id = ?", findingID).
		Update("last_seen", time.Now()).Error
}

// GetFindingSummaryByVulnerability gets a summary of findings for a vulnerability
func (s *VulnerabilityFindingService) GetFindingSummaryByVulnerability(vulnerabilityID uuid.UUID) (map[string]interface{}, error) {
	type StatusCount struct {
		Status models.FindingStatus
		Count  int64
	}

	var statusCounts []StatusCount
	err := s.db.Model(&models.VulnerabilityFinding{}).
		Select("status, COUNT(*) as count").
		Where("vulnerability_id = ?", vulnerabilityID).
		Group("status").
		Scan(&statusCounts).Error

	if err != nil {
		return nil, err
	}

	summary := map[string]interface{}{
		"total": int64(0),
	}

	for _, sc := range statusCounts {
		summary[string(sc.Status)] = sc.Count
		summary["total"] = summary["total"].(int64) + sc.Count
	}

	return summary, nil
}

// FindOrCreateFinding finds an existing finding or creates a new one
// Used during scan imports to update last_seen for existing findings
func (s *VulnerabilityFindingService) FindOrCreateFinding(finding *models.VulnerabilityFinding) (*models.VulnerabilityFinding, bool, error) {
	return s.FindOrCreateFindingWithTx(s.db, finding)
}

// FindOrCreateFindingWithTx finds or creates a finding using the provided DB/transaction
func (s *VulnerabilityFindingService) FindOrCreateFindingWithTx(tx *gorm.DB, finding *models.VulnerabilityFinding) (*models.VulnerabilityFinding, bool, error) {
	var existing models.VulnerabilityFinding

	// Try to find existing finding
	err := tx.Where(
		"vulnerability_id = ? AND affected_system_id = ? AND port = ? AND protocol = ?",
		finding.VulnerabilityID,
		finding.AffectedSystemID,
		finding.Port,
		finding.Protocol,
	).First(&existing).Error

	if err == nil {
		// Found existing - update last_seen with the scan timestamp
		tx.Model(&existing).Updates(map[string]interface{}{
			"last_seen":     finding.LastSeen, // Use scan timestamp, not current time
			"plugin_output": finding.PluginOutput, // Update with latest scan output
		})
		return &existing, false, nil
	}

	if err != gorm.ErrRecordNotFound {
		return nil, false, err
	}

	// Create new finding
	if err := tx.Create(finding).Error; err != nil {
		return nil, false, err
	}

	return finding, true, nil
}

// GetExpiredRiskAcceptances returns findings with expired risk acceptances
func (s *VulnerabilityFindingService) GetExpiredRiskAcceptances() ([]models.VulnerabilityFinding, error) {
	var findings []models.VulnerabilityFinding
	now := time.Now()

	err := s.db.
		Preload("Vulnerability").
		Preload("AffectedSystem").
		Where("status = ? AND expires_at IS NOT NULL AND expires_at < ?", models.FindingStatusAccepted, now).
		Find(&findings).Error

	return findings, err
}

// GetFindingStatistics gets global statistics for all findings
func (s *VulnerabilityFindingService) GetFindingStatistics(filters map[string]interface{}) (map[string]interface{}, error) {
	type StatusCount struct {
		Status models.FindingStatus
		Count  int64
	}

	query := s.db.Model(&models.VulnerabilityFinding{})

	// Apply same filters as ListFindings for consistency
	if status, ok := filters["status"].(string); ok && status != "" {
		query = query.Where("status = ?", status)
	}
	if severity, ok := filters["severity"].(string); ok && severity != "" {
		query = query.Joins("JOIN vulnerabilities ON vulnerabilities.id = vulnerability_findings.vulnerability_id").
			Where("vulnerabilities.severity = ?", severity)
	}
	if pluginID, ok := filters["plugin_id"].(string); ok && pluginID != "" {
		query = query.Where("plugin_id = ?", pluginID)
	}

	// Get status counts
	var statusCounts []StatusCount
	err := query.Select("status, COUNT(*) as count").
		Group("status").
		Scan(&statusCounts).Error

	if err != nil {
		return nil, err
	}

	// Calculate totals
	var total int64
	stats := map[string]interface{}{
		"total":        int64(0),
		"open":         int64(0),
		"mitigated":    int64(0),
		"fixed":        int64(0),
		"verified":     int64(0),
		"accepted":     int64(0),
		"exception":    int64(0),
	}

	for _, sc := range statusCounts {
		total += sc.Count
		switch sc.Status {
		case models.FindingStatusOpen:
			stats["open"] = sc.Count
		case models.FindingStatusMitigated:
			stats["mitigated"] = sc.Count
		case models.FindingStatusFixed:
			stats["fixed"] = sc.Count
		case models.FindingStatusVerified:
			stats["verified"] = sc.Count
		case models.FindingStatusAccepted:
			stats["accepted"] = sc.Count
		case models.FindingStatusException:
			stats["exception"] = sc.Count
		}
	}

	stats["total"] = total

	// Calculate resolution rate
	resolved := stats["fixed"].(int64) + stats["verified"].(int64)
	if total > 0 {
		stats["resolution_rate"] = float64(resolved) / float64(total) * 100
	} else {
		stats["resolution_rate"] = float64(0)
	}

	return stats, nil
}

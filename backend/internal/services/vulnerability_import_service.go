package services

import (
	"fmt"

	"github.com/google/uuid"
	"github.com/cyops/cyops-backend/internal/models"
	"github.com/cyops/cyops-backend/pkg/database"
	"github.com/cyops/cyops-backend/pkg/utils"
	"gorm.io/gorm"
)

// ImportResult represents the result of an import operation
type ImportResult struct {
	TotalVulnerabilities    int                    `json:"total_vulnerabilities"`
	ImportedVulnerabilities int                    `json:"imported_vulnerabilities"`
	SkippedVulnerabilities  int                    `json:"skipped_vulnerabilities"`
	TotalAssets             int                    `json:"total_assets"`
	CreatedAssets           int                    `json:"created_assets"`
	ExistingAssets          int                    `json:"existing_assets"`
	TotalFindings           int                    `json:"total_findings"`
	CreatedFindings         int                    `json:"created_findings"`
	UpdatedFindings         int                    `json:"updated_findings"`
	Errors                  []string               `json:"errors,omitempty"`
	Warnings                []string               `json:"warnings,omitempty"`
	Summary                 map[string]interface{} `json:"summary"`
}

// VulnerabilityImportService handles importing vulnerabilities from external sources
type VulnerabilityImportService struct {
	db                  *gorm.DB
	vulnService         *VulnerabilityService
	findingService      *VulnerabilityFindingService
	assetService        *AssetService
	assetValidation     *AssetValidationService
}

// NewVulnerabilityImportService creates a new import service
func NewVulnerabilityImportService() *VulnerabilityImportService {
	db := database.GetDB()
	return &VulnerabilityImportService{
		db:                  db,
		vulnService:         NewVulnerabilityService(),
		findingService:      NewVulnerabilityFindingService(db),
		assetService:        NewAssetService(db),
		assetValidation:     NewAssetValidationService(db),
	}
}

// ImportFromNessus imports vulnerabilities from parsed Nessus data
func (s *VulnerabilityImportService) ImportFromNessus(
	vulnerabilities []ParsedVulnerability,
	createdByID uuid.UUID,
	skipDuplicates bool,
) (*ImportResult, error) {
	result := &ImportResult{
		TotalVulnerabilities: len(vulnerabilities),
		Errors:               []string{},
		Warnings:             []string{},
		Summary:              make(map[string]interface{}),
	}

	// Start transaction
	tx := s.db.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	for _, parsedVuln := range vulnerabilities {
		// Check for duplicate vulnerability by title or CVE
		if skipDuplicates {
			var existingCount int64
			query := tx.Model(&models.Vulnerability{})

			if parsedVuln.CVEID != "" {
				query = query.Where("cve_id = ?", parsedVuln.CVEID)
			} else {
				query = query.Where("title = ?", parsedVuln.Title)
			}

			query.Count(&existingCount)

			if existingCount > 0 {
				result.SkippedVulnerabilities++
				result.Warnings = append(result.Warnings,
					fmt.Sprintf("Skipped duplicate: %s", parsedVuln.Title))
				continue
			}
		}

		// Create or find affected systems and track host details
		type HostAssetPair struct {
			Host    ParsedHost
			AssetID uuid.UUID
		}
		affectedSystemIDs := []uuid.UUID{}
		hostAssetPairs := []HostAssetPair{}

		for _, host := range parsedVuln.AffectedHosts {
			assetID, created, err := s.findOrCreateAsset(tx, host, createdByID)
			if err != nil {
				result.Errors = append(result.Errors,
					fmt.Sprintf("Failed to create asset %s: %v", host.IPAddress, err))
				continue
			}

			affectedSystemIDs = append(affectedSystemIDs, assetID)
			hostAssetPairs = append(hostAssetPairs, HostAssetPair{Host: host, AssetID: assetID})
			result.TotalAssets++

			if created {
				result.CreatedAssets++
			} else {
				result.ExistingAssets++
			}
		}

		// Create vulnerability
		vulnerability := &models.Vulnerability{
			Title:                     parsedVuln.Title,
			Description:               parsedVuln.Description,
			Severity:                  parsedVuln.Severity,
			CVSSScore:                 parsedVuln.CVSSScore,
			CVSSVector:                parsedVuln.CVSSVector,
			CVEID:                     parsedVuln.CVEID,
			Status:                    models.StatusOpen,
			Source:                    "Nessus",
			DiscoveryDate:             parsedVuln.ScanDate,
			ImpactAssessment:          parsedVuln.ImpactAssessment,
			MitigationRecommendations: parsedVuln.MitigationRecommendations,
			CreatedByID:               createdByID,
		}

		if err := tx.Create(vulnerability).Error; err != nil {
			result.Errors = append(result.Errors,
				fmt.Sprintf("Failed to create vulnerability %s: %v", parsedVuln.Title, err))
			continue
		}

		// Link affected systems (deduplicate first - same asset may have multiple ports)
		uniqueAssetIDs := make(map[uuid.UUID]bool)
		for _, assetID := range affectedSystemIDs {
			uniqueAssetIDs[assetID] = true
		}

		for assetID := range uniqueAssetIDs {
			link := &models.VulnerabilityAffectedSystem{
				VulnerabilityID:  vulnerability.ID.String(),
				AffectedSystemID: assetID.String(),
			}
			if err := tx.Create(link).Error; err != nil {
				result.Warnings = append(result.Warnings,
					fmt.Sprintf("Failed to link asset to vulnerability: %v", err))
			}
		}

		// Create initial status history
		statusHistory := &models.VulnerabilityStatusHistory{
			VulnerabilityID: vulnerability.ID,
			OldStatus:       "",
			NewStatus:       models.StatusOpen,
			ChangedByID:     createdByID,
			Notes:           "Imported from Nessus scan",
		}
		if err := tx.Create(statusHistory).Error; err != nil {
			result.Warnings = append(result.Warnings,
				fmt.Sprintf("Failed to create status history: %v", err))
		}

		// Create individual findings for each affected host
		for _, pair := range hostAssetPairs {
			finding := &models.VulnerabilityFinding{
				VulnerabilityID:  vulnerability.ID,
				AffectedSystemID: pair.AssetID,
				Port:             pair.Host.Port,
				Protocol:         pair.Host.Protocol,
				ServiceName:      pair.Host.ServiceName,
				PluginID:         parsedVuln.PluginID,
				PluginOutput:     "", // Nessus output per host (not currently captured)
				ScannerName:      "nessus",
				Status:           models.FindingStatusOpen,
				FirstDetected:    pair.Host.ScanTimestamp,
				LastSeen:         pair.Host.ScanTimestamp,
				CreatedBy:        createdByID,
			}

			// Check if finding already exists (for rescans) - use transaction
			existingFinding, created, err := s.findingService.FindOrCreateFindingWithTx(tx, finding)
			if err != nil {
				result.Warnings = append(result.Warnings,
					fmt.Sprintf("Failed to create finding for asset %s: %v", pair.Host.IPAddress, err))
				continue
			}

			result.TotalFindings++
			if created {
				result.CreatedFindings++
			} else {
				result.UpdatedFindings++
				utils.Logger.Debug().
					Str("finding_id", existingFinding.ID.String()).
					Msg("Updated existing finding last_seen timestamp")
			}
		}

		result.ImportedVulnerabilities++
	}

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		return nil, fmt.Errorf("failed to commit import transaction: %w", err)
	}

	// Build summary
	successRate := 0.0
	if result.TotalVulnerabilities > 0 {
		successRate = float64(result.ImportedVulnerabilities) / float64(result.TotalVulnerabilities) * 100
	}

	result.Summary = map[string]interface{}{
		"success_rate": successRate,
		"has_errors":   len(result.Errors) > 0,
		"has_warnings": len(result.Warnings) > 0,
	}

	utils.Logger.Info().
		Int("total", result.TotalVulnerabilities).
		Int("imported", result.ImportedVulnerabilities).
		Int("skipped", result.SkippedVulnerabilities).
		Int("created_assets", result.CreatedAssets).
		Msg("Nessus import completed")

	return result, nil
}

// findOrCreateAsset finds an existing asset or creates a new one
func (s *VulnerabilityImportService) findOrCreateAsset(
	tx *gorm.DB,
	host ParsedHost,
	createdByID uuid.UUID,
) (uuid.UUID, bool, error) {
	// Try to find existing asset by IP or hostname
	var existingAsset models.AffectedSystem

	query := tx.Where("(ip_address = ? OR hostname = ?) AND environment = ?",
		host.IPAddress, host.Hostname, models.EnvProduction)

	if err := query.First(&existingAsset).Error; err == nil {
		// Asset exists
		return existingAsset.ID, false, nil
	} else if err != gorm.ErrRecordNotFound {
		return uuid.Nil, false, err
	}

	// Create new asset
	systemType := models.SystemTypeServer
	if host.ServiceName == "www" || host.ServiceName == "http" || host.ServiceName == "https" {
		systemType = models.SystemTypeApplication
	}

	description := fmt.Sprintf("Auto-imported from Nessus scan")
	if host.OS != "" {
		description = fmt.Sprintf("Auto-imported from Nessus scan. OS: %s", host.OS)
	}

	criticality := models.CriticalityMedium
	newAsset := &models.AffectedSystem{
		Hostname:     host.Hostname,
		IPAddress:    host.IPAddress,
		SystemType:   systemType,
		Environment:  models.EnvProduction,
		Status:       models.StatusActive,
		Criticality:  &criticality,
		Description:  description,
		OwnerID:      &createdByID,
	}

	if err := tx.Create(newAsset).Error; err != nil {
		return uuid.Nil, false, err
	}

	return newAsset.ID, true, nil
}

// ValidateNessusFile performs basic validation on uploaded file
func (s *VulnerabilityImportService) ValidateNessusFile(data []byte, filename string) error {
	// Check file size (max 50MB)
	maxSize := 50 * 1024 * 1024
	if len(data) > maxSize {
		return fmt.Errorf("file size exceeds maximum allowed size of 50MB")
	}

	// Check if it's XML
	if len(data) < 100 {
		return fmt.Errorf("file is too small to be a valid Nessus file")
	}

	// Check for Nessus XML marker
	content := string(data[:100])
	if !contains(content, "NessusClientData") && !contains(content, "<?xml") {
		return fmt.Errorf("file does not appear to be a valid Nessus XML file")
	}

	return nil
}

// contains checks if string contains substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > len(substr) &&
		(s[:len(substr)] == substr || s[len(s)-len(substr):] == substr ||
		 contains(s[1:], substr)))
}

package services

import (
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/cyops/cyops-backend/internal/models"
)

// VulnerabilityValidationService handles validation for vulnerability operations
type VulnerabilityValidationService struct{}

// NewVulnerabilityValidationService creates a new validation service
func NewVulnerabilityValidationService() *VulnerabilityValidationService {
	return &VulnerabilityValidationService{}
}

// CVE ID regex pattern: CVE-YYYY-NNNNN
var cveIDPattern = regexp.MustCompile(`^CVE-\d{4}-\d{4,}$`)

// ValidateCreateRequest validates a create vulnerability request
func (s *VulnerabilityValidationService) ValidateCreateRequest(req CreateVulnerabilityRequest) error {
	// Validate title
	if err := s.ValidateTitle(req.Title); err != nil {
		return err
	}

	// Validate description
	if err := s.ValidateDescription(req.Description); err != nil {
		return err
	}

	// Validate severity
	if err := s.ValidateSeverity(req.Severity); err != nil {
		return err
	}

	// Validate CVSS score if provided
	if req.CVSSScore != nil {
		if err := s.ValidateCVSSScore(*req.CVSSScore); err != nil {
			return err
		}
	}

	// Validate CVSS vector if provided
	if req.CVSSVector != "" {
		if err := s.ValidateCVSSVector(req.CVSSVector); err != nil {
			return err
		}
	}

	// Validate CVE ID if provided
	if req.CVEID != "" {
		if err := s.ValidateCVEID(req.CVEID); err != nil {
			return err
		}
	}

	// Validate discovery date
	if err := s.ValidateDiscoveryDate(req.DiscoveryDate); err != nil {
		return err
	}

	// Validate affected systems (required for create)
	if err := s.ValidateAffectedSystems(req.AffectedSystemIDs); err != nil {
		return err
	}

	// Validate text fields length
	if req.ImpactAssessment != "" && len(req.ImpactAssessment) > 10000 {
		return fmt.Errorf("impact assessment must be less than 10,000 characters")
	}

	if req.StepsToReproduce != "" && len(req.StepsToReproduce) > 10000 {
		return fmt.Errorf("steps to reproduce must be less than 10,000 characters")
	}

	if req.MitigationRecommendations != "" && len(req.MitigationRecommendations) > 10000 {
		return fmt.Errorf("mitigation recommendations must be less than 10,000 characters")
	}

	return nil
}

// ValidateUpdateRequest validates an update vulnerability request
func (s *VulnerabilityValidationService) ValidateUpdateRequest(req UpdateVulnerabilityRequest) error {
	// Validate title if provided
	if req.Title != nil {
		if err := s.ValidateTitle(*req.Title); err != nil {
			return err
		}
	}

	// Validate description if provided
	if req.Description != nil {
		if err := s.ValidateDescription(*req.Description); err != nil {
			return err
		}
	}

	// Validate severity if provided
	if req.Severity != nil {
		if err := s.ValidateSeverity(*req.Severity); err != nil {
			return err
		}
	}

	// Validate CVSS score if provided
	if req.CVSSScore != nil {
		if err := s.ValidateCVSSScore(*req.CVSSScore); err != nil {
			return err
		}
	}

	// Validate CVSS vector if provided
	if req.CVSSVector != nil && *req.CVSSVector != "" {
		if err := s.ValidateCVSSVector(*req.CVSSVector); err != nil {
			return err
		}
	}

	// Validate CVE ID if provided
	if req.CVEID != nil && *req.CVEID != "" {
		if err := s.ValidateCVEID(*req.CVEID); err != nil {
			return err
		}
	}

	// Validate text fields length
	if req.RemediationNotes != nil && len(*req.RemediationNotes) > 10000 {
		return fmt.Errorf("remediation notes must be less than 10,000 characters")
	}

	if req.ImpactAssessment != nil && len(*req.ImpactAssessment) > 10000 {
		return fmt.Errorf("impact assessment must be less than 10,000 characters")
	}

	if req.StepsToReproduce != nil && len(*req.StepsToReproduce) > 10000 {
		return fmt.Errorf("steps to reproduce must be less than 10,000 characters")
	}

	if req.MitigationRecommendations != nil && len(*req.MitigationRecommendations) > 10000 {
		return fmt.Errorf("mitigation recommendations must be less than 10,000 characters")
	}

	return nil
}

// ValidateTitle validates vulnerability title
func (s *VulnerabilityValidationService) ValidateTitle(title string) error {
	title = strings.TrimSpace(title)

	if title == "" {
		return fmt.Errorf("title is required")
	}

	if len(title) < 3 {
		return fmt.Errorf("title must be at least 3 characters")
	}

	if len(title) > 255 {
		return fmt.Errorf("title must be less than 255 characters")
	}

	return nil
}

// ValidateDescription validates vulnerability description
func (s *VulnerabilityValidationService) ValidateDescription(description string) error {
	description = strings.TrimSpace(description)

	if description == "" {
		return fmt.Errorf("description is required")
	}

	if len(description) < 10 {
		return fmt.Errorf("description must be at least 10 characters")
	}

	if len(description) > 10000 {
		return fmt.Errorf("description must be less than 10,000 characters")
	}

	return nil
}

// ValidateSeverity validates vulnerability severity
func (s *VulnerabilityValidationService) ValidateSeverity(severity models.VulnerabilitySeverity) error {
	validSeverities := []models.VulnerabilitySeverity{
		models.SeverityCritical,
		models.SeverityHigh,
		models.SeverityMedium,
		models.SeverityLow,
		models.SeverityNone,
	}

	for _, valid := range validSeverities {
		if severity == valid {
			return nil
		}
	}

	return fmt.Errorf("invalid severity: must be one of CRITICAL, HIGH, MEDIUM, LOW, NONE")
}

// ValidateCVSSScore validates CVSS score
func (s *VulnerabilityValidationService) ValidateCVSSScore(score float64) error {
	if score < 0.0 || score > 10.0 {
		return fmt.Errorf("CVSS score must be between 0.0 and 10.0")
	}

	return nil
}

// ValidateCVSSVector validates CVSS vector string
func (s *VulnerabilityValidationService) ValidateCVSSVector(vector string) error {
	vector = strings.TrimSpace(vector)

	if len(vector) > 100 {
		return fmt.Errorf("CVSS vector must be less than 100 characters")
	}

	// Basic validation - should start with CVSS:3.0/ or CVSS:3.1/
	if !strings.HasPrefix(vector, "CVSS:3.0/") && !strings.HasPrefix(vector, "CVSS:3.1/") {
		return fmt.Errorf("CVSS vector must start with 'CVSS:3.0/' or 'CVSS:3.1/'")
	}

	return nil
}

// ValidateCVEID validates CVE ID format
func (s *VulnerabilityValidationService) ValidateCVEID(cveID string) error {
	cveID = strings.TrimSpace(cveID)

	if cveID == "" {
		return nil // CVE ID is optional
	}

	if len(cveID) > 20 {
		return fmt.Errorf("CVE ID must be less than 20 characters")
	}

	if !cveIDPattern.MatchString(cveID) {
		return fmt.Errorf("CVE ID must be in format CVE-YYYY-NNNNN (e.g., CVE-2024-1234)")
	}

	return nil
}

// ValidateDiscoveryDate validates discovery date
func (s *VulnerabilityValidationService) ValidateDiscoveryDate(date time.Time) error {
	// Check if date is zero value
	if date.IsZero() {
		return fmt.Errorf("discovery date is required")
	}

	// Check if date is in the future
	now := time.Now()
	if date.After(now) {
		return fmt.Errorf("discovery date cannot be in the future")
	}

	// Check if date is too old (e.g., before 1990)
	minDate := time.Date(1990, 1, 1, 0, 0, 0, 0, time.UTC)
	if date.Before(minDate) {
		return fmt.Errorf("discovery date cannot be before 1990")
	}

	return nil
}

// ValidateStatusTransition validates if a status transition is allowed
func (s *VulnerabilityValidationService) ValidateStatusTransition(oldStatus, newStatus models.VulnerabilityStatus) error {
	// Define valid transitions
	validTransitions := map[models.VulnerabilityStatus][]models.VulnerabilityStatus{
		models.StatusOpen: {
			models.StatusInProgress,
			models.StatusFalsePositive,
		},
		models.StatusInProgress: {
			models.StatusResolved,
			models.StatusFalsePositive,
			models.StatusOpen,
		},
		models.StatusResolved: {
			models.StatusVerified,
			models.StatusInProgress,
		},
		models.StatusVerified: {
			models.StatusClosed,
			models.StatusInProgress,
		},
		models.StatusClosed: {
			// No transitions allowed from closed
		},
		models.StatusFalsePositive: {
			models.StatusOpen,
		},
	}

	// Check if transition is valid
	allowedTransitions, ok := validTransitions[oldStatus]
	if !ok {
		return fmt.Errorf("invalid current status: %s", oldStatus)
	}

	for _, allowed := range allowedTransitions {
		if newStatus == allowed {
			return nil
		}
	}

	return fmt.Errorf("invalid status transition from %s to %s", oldStatus, newStatus)
}

// ValidateUserID validates a user ID
func (s *VulnerabilityValidationService) ValidateUserID(userID uuid.UUID) error {
	if userID == uuid.Nil {
		return fmt.Errorf("user ID is required")
	}

	return nil
}

// ValidateStatus validates vulnerability status
func (s *VulnerabilityValidationService) ValidateStatus(status models.VulnerabilityStatus) error {
	validStatuses := []models.VulnerabilityStatus{
		models.StatusOpen,
		models.StatusInProgress,
		models.StatusResolved,
		models.StatusVerified,
		models.StatusClosed,
		models.StatusFalsePositive,
	}

	for _, valid := range validStatuses {
		if status == valid {
			return nil
		}
	}

	return fmt.Errorf("invalid status: must be one of OPEN, IN_PROGRESS, RESOLVED, VERIFIED, CLOSED, FALSE_POSITIVE")
}

// ValidateAffectedSystems validates that at least one affected system is provided
func (s *VulnerabilityValidationService) ValidateAffectedSystems(affectedSystemIDs []uuid.UUID) error {
	if len(affectedSystemIDs) == 0 {
		return fmt.Errorf("at least one affected system/asset is required")
	}

	// Validate each UUID
	for _, id := range affectedSystemIDs {
		if id == uuid.Nil {
			return fmt.Errorf("invalid affected system ID: cannot be empty")
		}
	}

	return nil
}

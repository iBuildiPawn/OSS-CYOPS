package handlers

import (
	"fmt"

	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
	"github.com/cyops/cyops-backend/internal/services"
	"github.com/cyops/cyops-backend/pkg/database"
)

type VulnerabilityAttachmentHandler struct {
	service *services.VulnerabilityAttachmentService
}

func NewVulnerabilityAttachmentHandler() *VulnerabilityAttachmentHandler {
	return &VulnerabilityAttachmentHandler{
		service: services.NewVulnerabilityAttachmentService(database.GetDB()),
	}
}

// UploadAttachment uploads a file attachment for a vulnerability
// POST /api/vulnerabilities/:id/attachments
func (h *VulnerabilityAttachmentHandler) UploadAttachment(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(uuid.UUID)

	vulnerabilityID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	// Get file from multipart form
	file, err := c.FormFile("file")
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "File is required",
		})
	}

	// Get attachment type and description from form
	attachmentType := c.FormValue("attachment_type", "PROOF")
	description := c.FormValue("description", "")

	// Validate attachment type
	validTypes := []string{"PROOF", "DOCUMENTATION", "OTHER"}
	isValidType := false
	for _, vt := range validTypes {
		if attachmentType == vt {
			isValidType = true
			break
		}
	}
	if !isValidType {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": fmt.Sprintf("Invalid attachment type. Must be one of: %v", validTypes),
		})
	}

	// Upload and process attachment
	attachment, err := h.service.UploadAttachment(
		vulnerabilityID,
		file,
		attachmentType,
		description,
		userID,
	)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": fmt.Sprintf("Failed to upload attachment: %v", err),
		})
	}

	return c.Status(fiber.StatusCreated).JSON(fiber.Map{
		"message": "Attachment uploaded successfully",
		"data":    attachment,
	})
}

// GetAttachment retrieves an attachment by ID
// GET /api/vulnerability-attachments/:id
func (h *VulnerabilityAttachmentHandler) GetAttachment(c *fiber.Ctx) error {
	attachmentID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid attachment ID",
		})
	}

	attachment, err := h.service.GetAttachment(attachmentID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Attachment not found",
		})
	}

	return c.JSON(fiber.Map{
		"data": attachment,
	})
}

// GetAttachmentFile serves the attachment file
// GET /api/vulnerability-attachments/:id/file
func (h *VulnerabilityAttachmentHandler) GetAttachmentFile(c *fiber.Ctx) error {
	attachmentID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid attachment ID",
		})
	}

	// Check if thumbnail is requested
	thumbnail := c.Query("thumbnail") == "true"

	attachment, err := h.service.GetAttachment(attachmentID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Attachment not found",
		})
	}

	// Get file data
	fileData, err := h.service.GetAttachmentFile(attachment, thumbnail)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to read attachment file",
		})
	}

	// Set appropriate headers
	c.Set("Content-Type", attachment.MimeType)
	c.Set("Content-Disposition", fmt.Sprintf("inline; filename=\"%s\"", attachment.OriginalName))

	return c.Send(fileData)
}

// DownloadAttachmentFile downloads the attachment file
// GET /api/vulnerability-attachments/:id/download
func (h *VulnerabilityAttachmentHandler) DownloadAttachmentFile(c *fiber.Ctx) error {
	attachmentID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid attachment ID",
		})
	}

	attachment, err := h.service.GetAttachment(attachmentID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Attachment not found",
		})
	}

	// Get file data (always full file, never thumbnail)
	fileData, err := h.service.GetAttachmentFile(attachment, false)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to read attachment file",
		})
	}

	// Set download headers
	c.Set("Content-Type", attachment.MimeType)
	c.Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", attachment.OriginalName))

	return c.Send(fileData)
}

// ListVulnerabilityAttachments lists all attachments for a vulnerability
// GET /api/vulnerabilities/:id/attachments
func (h *VulnerabilityAttachmentHandler) ListVulnerabilityAttachments(c *fiber.Ctx) error {
	vulnerabilityID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	attachments, err := h.service.GetVulnerabilityAttachments(vulnerabilityID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to list attachments",
		})
	}

	return c.JSON(fiber.Map{
		"data": attachments,
	})
}

// DeleteAttachment soft deletes an attachment
// DELETE /api/vulnerability-attachments/:id
func (h *VulnerabilityAttachmentHandler) DeleteAttachment(c *fiber.Ctx) error {
	attachmentID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid attachment ID",
		})
	}

	if err := h.service.DeleteAttachment(attachmentID); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to delete attachment",
		})
	}

	return c.JSON(fiber.Map{
		"message": "Attachment deleted successfully",
	})
}

// GetAttachmentStats returns statistics about attachments
// GET /api/vulnerabilities/:id/attachments/stats
func (h *VulnerabilityAttachmentHandler) GetAttachmentStats(c *fiber.Ctx) error {
	var vulnerabilityID *uuid.UUID

	// If vulnerability ID is provided in path, get stats for that vulnerability
	if idParam := c.Params("id"); idParam != "" {
		id, err := uuid.Parse(idParam)
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
				"error": "Invalid vulnerability ID",
			})
		}
		vulnerabilityID = &id
	}

	stats, err := h.service.GetAttachmentStats(vulnerabilityID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to get attachment statistics",
		})
	}

	return c.JSON(fiber.Map{
		"data": stats,
	})
}

package handlers

import (
	"strings"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
	"github.com/cyops/cyops-backend/internal/middleware"
	"github.com/cyops/cyops-backend/internal/models"
	"github.com/cyops/cyops-backend/internal/services"
	"github.com/cyops/cyops-backend/pkg/utils"
)

// VulnerabilityHandler handles vulnerability-related requests
type VulnerabilityHandler struct {
	vulnerabilityService *services.VulnerabilityService
	validationService    *services.VulnerabilityValidationService
}

// sanitizeStringPtr sanitizes a string pointer, returning nil if input is nil
func sanitizeStringPtr(s *string) *string {
	if s == nil {
		return nil
	}
	sanitized := utils.SanitizeString(*s)
	return &sanitized
}

// NewVulnerabilityHandler creates a new vulnerability handler
func NewVulnerabilityHandler() *VulnerabilityHandler {
	return &VulnerabilityHandler{
		vulnerabilityService: services.NewVulnerabilityService(),
		validationService:    services.NewVulnerabilityValidationService(),
	}
}

// CreateVulnerabilityRequest represents a create vulnerability request
type CreateVulnerabilityRequest struct {
	Title                     string   `json:"title"`
	Description               string   `json:"description"`
	Severity                  string   `json:"severity"`
	CVSSScore                 *float64 `json:"cvss_score,omitempty"`
	CVSSVector                string   `json:"cvss_vector,omitempty"`
	CVEID                     string   `json:"cve_id,omitempty"`
	Source                    string   `json:"source,omitempty"`
	DiscoveryDate             string   `json:"discovery_date"` // ISO date format
	ImpactAssessment          string   `json:"impact_assessment,omitempty"`
	StepsToReproduce          string   `json:"steps_to_reproduce,omitempty"`
	MitigationRecommendations string   `json:"mitigation_recommendations,omitempty"`
	AssignedToID              *string  `json:"assigned_to_id,omitempty"`
	AffectedSystemIDs         []string `json:"affected_system_ids,omitempty"`
}

// CreateVulnerability creates a new vulnerability
func (h *VulnerabilityHandler) CreateVulnerability(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(uuid.UUID)

	var req CreateVulnerabilityRequest
	if err := c.BodyParser(&req); err != nil {
		return middleware.ValidationError(c, "Invalid request body", nil)
	}

	// Validate CVE ID format if provided
	if req.CVEID != "" {
		if err := utils.ValidateCVEID(req.CVEID); err != nil {
			return middleware.ValidationError(c, err.Error(), nil)
		}
	}

	// Parse discovery date
	discoveryDate, err := time.Parse("2006-01-02", req.DiscoveryDate)
	if err != nil {
		return middleware.ValidationError(c, "Invalid discovery date format (use YYYY-MM-DD)", nil)
	}

	// Parse assigned to ID if provided
	var assignedToID *uuid.UUID
	if req.AssignedToID != nil && *req.AssignedToID != "" {
		parsed, err := uuid.Parse(*req.AssignedToID)
		if err != nil {
			return middleware.ValidationError(c, "Invalid assigned_to_id format", nil)
		}
		assignedToID = &parsed
	}

	// Parse affected system IDs
	var affectedSystemIDs []uuid.UUID
	for _, idStr := range req.AffectedSystemIDs {
		systemID, err := uuid.Parse(idStr)
		if err != nil {
			return middleware.ValidationError(c, "Invalid affected_system_id format", nil)
		}
		affectedSystemIDs = append(affectedSystemIDs, systemID)
	}

	// Set default source if not provided
	source := req.Source
	if source == "" {
		source = "Manual"
	}

	// Convert to service request with input sanitization
	serviceReq := services.CreateVulnerabilityRequest{
		Title:                     utils.SanitizeString(req.Title),
		Description:               utils.SanitizeString(req.Description),
		Severity:                  models.VulnerabilitySeverity(req.Severity),
		CVSSScore:                 req.CVSSScore,
		CVSSVector:                req.CVSSVector,
		CVEID:                     req.CVEID,
		Source:                    source,
		DiscoveryDate:             discoveryDate,
		ImpactAssessment:          utils.SanitizeString(req.ImpactAssessment),
		StepsToReproduce:          utils.SanitizeString(req.StepsToReproduce),
		MitigationRecommendations: utils.SanitizeString(req.MitigationRecommendations),
		AssignedToID:              assignedToID,
		AffectedSystemIDs:         affectedSystemIDs,
	}

	// Validate request
	if err := h.validationService.ValidateCreateRequest(serviceReq); err != nil {
		return middleware.ValidationError(c, err.Error(), nil)
	}

	// Create vulnerability
	vulnerability, err := h.vulnerabilityService.CreateVulnerability(serviceReq, userID)
	if err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to create vulnerability")
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to create vulnerability",
		})
	}

	return c.Status(fiber.StatusCreated).JSON(fiber.Map{
		"message": "Vulnerability created successfully",
		"data":    vulnerability,
	})
}

// ListVulnerabilitiesQuery represents query parameters for listing vulnerabilities
type ListVulnerabilitiesQuery struct {
	Page       int    `query:"page"`
	Limit      int    `query:"limit"`
	Severity   string `query:"severity"` // Comma-separated
	Status     string `query:"status"`   // Comma-separated
	Search     string `query:"search"`
	AssignedTo string `query:"assignedTo"`
	CreatedBy  string `query:"createdBy"`
	AssetID    string `query:"asset_id"` // Filter by affected system/asset
	SortBy     string `query:"sortBy"`
	SortOrder  string `query:"sortOrder"`
}

// ListVulnerabilities lists vulnerabilities with pagination and filters
func (h *VulnerabilityHandler) ListVulnerabilities(c *fiber.Ctx) error {
	var query ListVulnerabilitiesQuery
	if err := c.QueryParser(&query); err != nil {
		return middleware.ValidationError(c, "Invalid query parameters", nil)
	}

	// Parse severity filter
	var severities []models.VulnerabilitySeverity
	if query.Severity != "" {
		for _, s := range strings.Split(query.Severity, ",") {
			severities = append(severities, models.VulnerabilitySeverity(strings.TrimSpace(s)))
		}
	}

	// Parse status filter
	var statuses []models.VulnerabilityStatus
	if query.Status != "" {
		for _, s := range strings.Split(query.Status, ",") {
			statuses = append(statuses, models.VulnerabilityStatus(strings.TrimSpace(s)))
		}
	}

	// Parse assigned to filter
	var assignedTo *uuid.UUID
	if query.AssignedTo != "" {
		parsed, err := uuid.Parse(query.AssignedTo)
		if err != nil {
			return middleware.ValidationError(c, "Invalid assignedTo format", nil)
		}
		assignedTo = &parsed
	}

	// Parse created by filter
	var createdBy *uuid.UUID
	if query.CreatedBy != "" {
		parsed, err := uuid.Parse(query.CreatedBy)
		if err != nil {
			return middleware.ValidationError(c, "Invalid createdBy format", nil)
		}
		createdBy = &parsed
	}

	// Parse asset ID filter
	var assetID *uuid.UUID
	if query.AssetID != "" {
		parsed, err := uuid.Parse(query.AssetID)
		if err != nil {
			return middleware.ValidationError(c, "Invalid asset_id format", nil)
		}
		assetID = &parsed
	}

	// Build service request
	serviceReq := services.ListVulnerabilitiesRequest{
		Page:       query.Page,
		Limit:      query.Limit,
		Severity:   severities,
		Status:     statuses,
		Search:     query.Search,
		AssignedTo: assignedTo,
		CreatedBy:  createdBy,
		AssetID:    assetID,
		SortBy:     query.SortBy,
		SortOrder:  query.SortOrder,
	}

	// Get vulnerabilities
	vulnerabilities, total, err := h.vulnerabilityService.ListVulnerabilities(serviceReq)
	if err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to list vulnerabilities")
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to list vulnerabilities",
		})
	}

	// Calculate pagination metadata
	page := 1
	if query.Page > 0 {
		page = query.Page
	}
	limit := 50
	if query.Limit > 0 {
		limit = query.Limit
	}
	totalPages := int((total + int64(limit) - 1) / int64(limit))

	return c.JSON(fiber.Map{
		"data": vulnerabilities,
		"meta": fiber.Map{
			"page":        page,
			"limit":       limit,
			"total":       total,
			"total_pages": totalPages,
		},
	})
}

// GetVulnerability retrieves a vulnerability by ID
func (h *VulnerabilityHandler) GetVulnerability(c *fiber.Ctx) error {
	idParam := c.Params("id")
	id, err := uuid.Parse(idParam)
	if err != nil {
		return middleware.ValidationError(c, "Invalid vulnerability ID", nil)
	}

	vulnerability, err := h.vulnerabilityService.GetVulnerabilityByID(id)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"error": "Vulnerability not found",
			})
		}
		utils.Logger.Error().Err(err).Msg("Failed to get vulnerability")
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to get vulnerability",
		})
	}

	return c.JSON(fiber.Map{
		"data": vulnerability,
	})
}

// UpdateVulnerabilityRequest represents an update vulnerability request
type UpdateVulnerabilityRequest struct {
	Title                     *string  `json:"title,omitempty"`
	Description               *string  `json:"description,omitempty"`
	Severity                  *string  `json:"severity,omitempty"`
	CVSSScore                 *float64 `json:"cvss_score,omitempty"`
	CVSSVector                *string  `json:"cvss_vector,omitempty"`
	CVEID                     *string  `json:"cve_id,omitempty"`
	RemediationNotes          *string  `json:"remediation_notes,omitempty"`
	ImpactAssessment          *string  `json:"impact_assessment,omitempty"`
	StepsToReproduce          *string  `json:"steps_to_reproduce,omitempty"`
	MitigationRecommendations *string  `json:"mitigation_recommendations,omitempty"`
}

// UpdateVulnerability updates a vulnerability
func (h *VulnerabilityHandler) UpdateVulnerability(c *fiber.Ctx) error {
	idParam := c.Params("id")
	id, err := uuid.Parse(idParam)
	if err != nil {
		return middleware.ValidationError(c, "Invalid vulnerability ID", nil)
	}

	var req UpdateVulnerabilityRequest
	if err := c.BodyParser(&req); err != nil {
		return middleware.ValidationError(c, "Invalid request body", nil)
	}

	// Validate CVE ID format if provided
	if req.CVEID != nil && *req.CVEID != "" {
		if err := utils.ValidateCVEID(*req.CVEID); err != nil {
			return middleware.ValidationError(c, err.Error(), nil)
		}
	}

	// Convert to service request with input sanitization
	serviceReq := services.UpdateVulnerabilityRequest{
		Title:                     sanitizeStringPtr(req.Title),
		Description:               sanitizeStringPtr(req.Description),
		CVSSScore:                 req.CVSSScore,
		CVSSVector:                req.CVSSVector,
		CVEID:                     req.CVEID,
		RemediationNotes:          sanitizeStringPtr(req.RemediationNotes),
		ImpactAssessment:          sanitizeStringPtr(req.ImpactAssessment),
		StepsToReproduce:          sanitizeStringPtr(req.StepsToReproduce),
		MitigationRecommendations: sanitizeStringPtr(req.MitigationRecommendations),
	}

	// Convert severity if provided
	if req.Severity != nil {
		severity := models.VulnerabilitySeverity(*req.Severity)
		serviceReq.Severity = &severity
	}

	// Validate request
	if err := h.validationService.ValidateUpdateRequest(serviceReq); err != nil {
		return middleware.ValidationError(c, err.Error(), nil)
	}

	// Update vulnerability
	vulnerability, err := h.vulnerabilityService.UpdateVulnerability(id, serviceReq)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"error": "Vulnerability not found",
			})
		}
		utils.Logger.Error().Err(err).Msg("Failed to update vulnerability")
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to update vulnerability",
		})
	}

	return c.JSON(fiber.Map{
		"message": "Vulnerability updated successfully",
		"data":    vulnerability,
	})
}

// UpdateStatusRequest represents a status update request
type UpdateStatusRequest struct {
	Status string  `json:"status"`
	Notes  *string `json:"notes,omitempty"`
}

// UpdateVulnerabilityStatus updates a vulnerability's status
func (h *VulnerabilityHandler) UpdateVulnerabilityStatus(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(uuid.UUID)

	idParam := c.Params("id")
	id, err := uuid.Parse(idParam)
	if err != nil {
		return middleware.ValidationError(c, "Invalid vulnerability ID", nil)
	}

	var req UpdateStatusRequest
	if err := c.BodyParser(&req); err != nil {
		return middleware.ValidationError(c, "Invalid request body", nil)
	}

	newStatus := models.VulnerabilityStatus(req.Status)

	// Validate status
	if err := h.validationService.ValidateStatus(newStatus); err != nil {
		return middleware.ValidationError(c, err.Error(), nil)
	}

	// Get current vulnerability to check status transition
	currentVuln, err := h.vulnerabilityService.GetVulnerabilityByID(id)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"error": "Vulnerability not found",
			})
		}
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to get vulnerability",
		})
	}

	// Validate status transition
	if err := h.validationService.ValidateStatusTransition(currentVuln.Status, newStatus); err != nil {
		return middleware.ValidationError(c, err.Error(), nil)
	}

	notes := ""
	if req.Notes != nil {
		notes = *req.Notes
	}

	// Update status
	vulnerability, err := h.vulnerabilityService.UpdateVulnerabilityStatus(id, newStatus, notes, userID)
	if err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to update vulnerability status")
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(fiber.Map{
		"message": "Vulnerability status updated successfully",
		"data":    vulnerability,
	})
}

// AssignVulnerabilityRequest represents an assignment request
type AssignVulnerabilityRequest struct {
	AssignedToID *string `json:"assigned_to_id"`
}

// AssignVulnerability assigns a vulnerability to a user
func (h *VulnerabilityHandler) AssignVulnerability(c *fiber.Ctx) error {
	idParam := c.Params("id")
	id, err := uuid.Parse(idParam)
	if err != nil {
		return middleware.ValidationError(c, "Invalid vulnerability ID", nil)
	}

	var req AssignVulnerabilityRequest
	if err := c.BodyParser(&req); err != nil {
		return middleware.ValidationError(c, "Invalid request body", nil)
	}

	// Parse assigned to ID
	var assignedToID *uuid.UUID
	if req.AssignedToID != nil && *req.AssignedToID != "" {
		parsed, err := uuid.Parse(*req.AssignedToID)
		if err != nil {
			return middleware.ValidationError(c, "Invalid assigned_to_id format", nil)
		}
		assignedToID = &parsed
	}

	// Assign vulnerability
	vulnerability, err := h.vulnerabilityService.AssignVulnerability(id, assignedToID)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"error": "Vulnerability not found",
			})
		}
		utils.Logger.Error().Err(err).Msg("Failed to assign vulnerability")
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to assign vulnerability",
		})
	}

	return c.JSON(fiber.Map{
		"message": "Vulnerability assigned successfully",
		"data":    vulnerability,
	})
}

// DeleteVulnerability soft deletes a vulnerability
func (h *VulnerabilityHandler) DeleteVulnerability(c *fiber.Ctx) error {
	idParam := c.Params("id")
	id, err := uuid.Parse(idParam)
	if err != nil {
		return middleware.ValidationError(c, "Invalid vulnerability ID", nil)
	}

	// Delete vulnerability
	if err := h.vulnerabilityService.DeleteVulnerability(id); err != nil {
		if strings.Contains(err.Error(), "not found") {
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"error": "Vulnerability not found",
			})
		}
		utils.Logger.Error().Err(err).Msg("Failed to delete vulnerability")
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to delete vulnerability",
		})
	}

	return c.JSON(fiber.Map{
		"message": "Vulnerability deleted successfully",
	})
}

// GetVulnerabilityStats returns statistics about vulnerabilities
func (h *VulnerabilityHandler) GetVulnerabilityStats(c *fiber.Ctx) error {
	stats, err := h.vulnerabilityService.GetVulnerabilityStats()
	if err != nil {
		utils.Logger.Error().Err(err).Msg("Failed to get vulnerability stats")
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to get vulnerability statistics",
		})
	}

	return c.JSON(fiber.Map{
		"data": stats,
	})
}

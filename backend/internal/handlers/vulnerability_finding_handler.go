package handlers

import (
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
	"github.com/cyops/cyops-backend/internal/models"
	"github.com/cyops/cyops-backend/internal/services"
	"github.com/cyops/cyops-backend/pkg/database"
)

type VulnerabilityFindingHandler struct {
	service *services.VulnerabilityFindingService
}

func NewVulnerabilityFindingHandler() *VulnerabilityFindingHandler {
	return &VulnerabilityFindingHandler{
		service: services.NewVulnerabilityFindingService(database.GetDB()),
	}
}

// ListFindingsByVulnerability lists all findings for a vulnerability
func (h *VulnerabilityFindingHandler) ListFindingsByVulnerability(c *fiber.Ctx) error {
	vulnID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	// Optional status filter
	var status *models.FindingStatus
	if statusParam := c.Query("status"); statusParam != "" {
		s := models.FindingStatus(statusParam)
		status = &s
	}

	findings, err := h.service.ListFindingsByVulnerability(vulnID, status)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to list findings",
		})
	}

	// Get summary
	summary, err := h.service.GetFindingSummaryByVulnerability(vulnID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to get finding summary",
		})
	}

	return c.JSON(fiber.Map{
		"data":    findings,
		"summary": summary,
	})
}

// ListFindingsBySystem lists all findings for a system
func (h *VulnerabilityFindingHandler) ListFindingsBySystem(c *fiber.Ctx) error {
	systemID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid system ID",
		})
	}

	// Optional status filter
	var status *models.FindingStatus
	if statusParam := c.Query("status"); statusParam != "" {
		s := models.FindingStatus(statusParam)
		status = &s
	}

	findings, err := h.service.ListFindingsBySystem(systemID, status)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to list findings",
		})
	}

	return c.JSON(fiber.Map{
		"data": findings,
	})
}

// GetFinding retrieves a single finding
func (h *VulnerabilityFindingHandler) GetFinding(c *fiber.Ctx) error {
	findingID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid finding ID",
		})
	}

	finding, err := h.service.GetFinding(findingID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Finding not found",
		})
	}

	return c.JSON(fiber.Map{
		"data": finding,
	})
}

// MarkFindingFixed marks a finding as fixed
func (h *VulnerabilityFindingHandler) MarkFindingFixed(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(uuid.UUID)
	findingID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid finding ID",
		})
	}

	var req struct {
		Notes string `json:"notes"`
	}
	if err := c.BodyParser(&req); err != nil {
		// Notes are optional
	}

	if err := h.service.MarkFindingFixed(findingID, userID, req.Notes); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to mark finding as fixed",
		})
	}

	return c.JSON(fiber.Map{
		"message": "Finding marked as fixed successfully",
	})
}

// MarkFindingVerified marks a finding as verified
func (h *VulnerabilityFindingHandler) MarkFindingVerified(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(uuid.UUID)
	findingID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid finding ID",
		})
	}

	var req struct {
		Notes string `json:"notes"`
	}
	if err := c.BodyParser(&req); err != nil {
		// Notes are optional
	}

	if err := h.service.MarkFindingVerified(findingID, userID, req.Notes); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to mark finding as verified",
		})
	}

	return c.JSON(fiber.Map{
		"message": "Finding marked as verified successfully",
	})
}

// AcceptRisk accepts risk for a finding
func (h *VulnerabilityFindingHandler) AcceptRisk(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(uuid.UUID)
	findingID, err := uuid.Parse(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid finding ID",
		})
	}

	var req struct {
		Reason    string     `json:"reason"`
		ExpiresAt *time.Time `json:"expires_at"`
	}
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	if req.Reason == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Reason is required for risk acceptance",
		})
	}

	if err := h.service.AcceptRisk(findingID, userID, req.Reason, req.ExpiresAt); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to accept risk for finding",
		})
	}

	return c.JSON(fiber.Map{
		"message": "Risk accepted successfully",
	})
}

// ListFindings lists all findings with filters
func (h *VulnerabilityFindingHandler) ListFindings(c *fiber.Ctx) error {
	page := c.QueryInt("page", 1)
	limit := c.QueryInt("limit", 20)

	filters := make(map[string]interface{})
	if status := c.Query("status"); status != "" {
		filters["status"] = status
	}
	if severity := c.Query("severity"); severity != "" {
		filters["severity"] = severity
	}
	if pluginID := c.Query("plugin_id"); pluginID != "" {
		filters["plugin_id"] = pluginID
	}

	findings, total, err := h.service.ListFindings(filters, page, limit)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to list findings",
		})
	}

	// Enhance findings with attachment counts
	type FindingWithAttachments struct {
		models.VulnerabilityFinding
		AttachmentsCount int `json:"attachments_count"`
	}

	enhancedFindings := make([]FindingWithAttachments, len(findings))
	for i, finding := range findings {
		var count int64
		database.GetDB().Model(&models.FindingAttachment{}).
			Where("finding_id = ?", finding.ID).
			Count(&count)

		enhancedFindings[i] = FindingWithAttachments{
			VulnerabilityFinding: finding,
			AttachmentsCount:     int(count),
		}
	}

	return c.JSON(fiber.Map{
		"data": enhancedFindings,
		"meta": fiber.Map{
			"page":  page,
			"limit": limit,
			"total": total,
		},
	})
}

// GetFindingStatistics returns statistics for findings with optional filters
func (h *VulnerabilityFindingHandler) GetFindingStatistics(c *fiber.Ctx) error {
	filters := make(map[string]interface{})
	if status := c.Query("status"); status != "" {
		filters["status"] = status
	}
	if severity := c.Query("severity"); severity != "" {
		filters["severity"] = severity
	}
	if pluginID := c.Query("plugin_id"); pluginID != "" {
		filters["plugin_id"] = pluginID
	}

	stats, err := h.service.GetFindingStatistics(filters)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to get finding statistics",
		})
	}

	return c.JSON(fiber.Map{
		"data": stats,
	})
}

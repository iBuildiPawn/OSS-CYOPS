package integration

import (
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/cyops/cyops-backend/internal/models"
	"github.com/cyops/cyops-backend/internal/services"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

// setupTestDB creates a test database connection
func setupTestDB(t *testing.T) *gorm.DB {
	dsn := "host=localhost user=postgres password=postgres dbname=cyberops_test port=5432 sslmode=disable TimeZone=UTC"

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	require.NoError(t, err)

	return db
}

// TestVulnerabilityAutoAssetCreation tests the complete workflow of creating a vulnerability with new affected systems
func TestVulnerabilityAutoAssetCreation(t *testing.T) {
	// Setup test database
	db := setupTestDB(t)
	require.NotNil(t, db)

	// Clean up test data
	defer func() {
		db.Exec("DELETE FROM vulnerability_affected_systems WHERE vulnerability_id IN (SELECT id FROM vulnerabilities WHERE title LIKE 'Test Auto Asset%')")
		db.Exec("DELETE FROM vulnerabilities WHERE title LIKE 'Test Auto Asset%'")
		db.Exec("DELETE FROM affected_systems WHERE hostname LIKE 'test-auto-asset%'")
	}()

	// Create services
	assetService := services.NewAssetService(db)
	vulnService := services.NewVulnerabilityService()

	// Create a test user for vulnerability creation
	testUser := &models.User{
		Email:    "test-auto-asset@example.com",
		Name:     "Test User",
		Password: "hashedpassword",
	}
	db.Create(testUser)
	defer db.Delete(testUser)

	t.Run("CreateVulnerabilityWithNewAffectedSystems", func(t *testing.T) {
		// Prepare request with new affected systems
		hostname1 := "test-auto-asset-web-" + uuid.New().String()[:8]
		hostname2 := "test-auto-asset-db-" + uuid.New().String()[:8]

		req := services.CreateVulnerabilityRequest{
			Title:         "Test Auto Asset Vulnerability",
			Description:   "Testing auto-asset creation",
			Severity:      models.SeverityCritical,
			DiscoveryDate: time.Now(),
			NewAffectedSystems: []services.NewAffectedSystemData{
				{
					Hostname:    hostname1,
					IPAddress:   "192.168.100.1",
					SystemType:  models.SystemTypeServer,
					Environment: models.EnvProduction,
				},
				{
					Hostname:    hostname2,
					IPAddress:   "192.168.100.2",
					SystemType:  models.SystemTypeServer,
					Environment: models.EnvProduction,
				},
			},
		}

		// Create vulnerability with auto-asset creation
		result, err := vulnService.CreateVulnerabilityWithAutoAssets(req, testUser.ID)
		require.NoError(t, err)
		require.NotNil(t, result)
		require.NotNil(t, result.Vulnerability)

		// Verify vulnerability was created
		assert.Equal(t, "Test Auto Asset Vulnerability", result.Vulnerability.Title)
		assert.Equal(t, models.StatusOpen, result.Vulnerability.Status)

		// Verify assets were auto-created
		assert.Len(t, result.AutoCreatedAssets, 2, "Should have created 2 assets")

		// Verify asset details
		for _, autoCreated := range result.AutoCreatedAssets {
			assert.NotEmpty(t, autoCreated.ID)
			assert.NotEmpty(t, autoCreated.Hostname)

			// Verify asset exists in database
			var asset models.AffectedSystem
			err := db.First(&asset, "id = ?", autoCreated.ID).Error
			require.NoError(t, err)
			assert.Equal(t, models.StatusActive, asset.Status)
			assert.NotNil(t, asset.Criticality)
			assert.Equal(t, models.CriticalityMedium, *asset.Criticality)
		}

		// Verify assets are linked to vulnerability
		var affectedSystems []models.AffectedSystem
		err = db.Model(result.Vulnerability).Association("AffectedSystems").Find(&affectedSystems)
		require.NoError(t, err)
		assert.Len(t, affectedSystems, 2, "Vulnerability should have 2 affected systems")
	})

	t.Run("CreateVulnerabilityWithMixedSystems", func(t *testing.T) {
		// Create an existing asset
		existingHostname := "test-auto-asset-existing-" + uuid.New().String()[:8]
		existingAsset := &models.AffectedSystem{
			Hostname:    existingHostname,
			IPAddress:   "192.168.100.10",
			SystemType:  models.SystemTypeServer,
			Environment: models.EnvProduction,
			Status:      models.StatusActive,
		}
		err := assetService.Create(existingAsset)
		require.NoError(t, err)

		// Prepare request with mixed existing and new systems
		newHostname := "test-auto-asset-new-" + uuid.New().String()[:8]
		req := services.CreateVulnerabilityRequest{
			Title:             "Test Mixed Systems Vulnerability",
			Description:       "Testing mixed existing and new systems",
			Severity:          models.SeverityHigh,
			DiscoveryDate:     time.Now(),
			AffectedSystemIDs: []uuid.UUID{existingAsset.ID},
			NewAffectedSystems: []services.NewAffectedSystemData{
				{
					Hostname:    newHostname,
					IPAddress:   "192.168.100.11",
					SystemType:  models.SystemTypeWorkstation,
					Environment: models.EnvProduction,
				},
			},
		}

		// Create vulnerability
		result, err := vulnService.CreateVulnerabilityWithAutoAssets(req, testUser.ID)
		require.NoError(t, err)
		require.NotNil(t, result)

		// Verify only 1 asset was auto-created (the new one)
		assert.Len(t, result.AutoCreatedAssets, 1, "Should have created only 1 new asset")
		assert.Equal(t, newHostname, result.AutoCreatedAssets[0].Hostname)

		// Verify vulnerability has both systems linked
		var affectedSystems []models.AffectedSystem
		err = db.Model(result.Vulnerability).Association("AffectedSystems").Find(&affectedSystems)
		require.NoError(t, err)
		assert.Len(t, affectedSystems, 2, "Vulnerability should have 2 affected systems (1 existing + 1 new)")

		// Verify the systems are the correct ones
		hostnames := []string{affectedSystems[0].Hostname, affectedSystems[1].Hostname}
		assert.Contains(t, hostnames, existingHostname)
		assert.Contains(t, hostnames, newHostname)
	})

	t.Run("ReuseExistingAssetInNewVulnerability", func(t *testing.T) {
		// Create an asset first
		hostname := "test-auto-asset-reuse-" + uuid.New().String()[:8]
		req1 := services.CreateVulnerabilityRequest{
			Title:         "First Vulnerability",
			Description:   "First vulnerability",
			Severity:      models.SeverityMedium,
			DiscoveryDate: time.Now(),
			NewAffectedSystems: []services.NewAffectedSystemData{
				{
					Hostname:    hostname,
					IPAddress:   "192.168.100.20",
					SystemType:  models.SystemTypeServer,
					Environment: models.EnvProduction,
				},
			},
		}

		result1, err := vulnService.CreateVulnerabilityWithAutoAssets(req1, testUser.ID)
		require.NoError(t, err)
		assert.Len(t, result1.AutoCreatedAssets, 1, "First vulnerability should create the asset")

		// Create second vulnerability with same hostname
		req2 := services.CreateVulnerabilityRequest{
			Title:         "Second Vulnerability",
			Description:   "Second vulnerability",
			Severity:      models.SeverityLow,
			DiscoveryDate: time.Now(),
			NewAffectedSystems: []services.NewAffectedSystemData{
				{
					Hostname:    hostname,
					IPAddress:   "192.168.100.20",
					SystemType:  models.SystemTypeServer,
					Environment: models.EnvProduction,
				},
			},
		}

		result2, err := vulnService.CreateVulnerabilityWithAutoAssets(req2, testUser.ID)
		require.NoError(t, err)
		assert.Len(t, result2.AutoCreatedAssets, 0, "Second vulnerability should reuse existing asset, not create new")

		// Verify the same asset is linked to both vulnerabilities
		var asset1Systems []models.AffectedSystem
		err = db.Model(result1.Vulnerability).Association("AffectedSystems").Find(&asset1Systems)
		require.NoError(t, err)
		require.Len(t, asset1Systems, 1)

		var asset2Systems []models.AffectedSystem
		err = db.Model(result2.Vulnerability).Association("AffectedSystems").Find(&asset2Systems)
		require.NoError(t, err)
		require.Len(t, asset2Systems, 1)

		assert.Equal(t, asset1Systems[0].ID, asset2Systems[0].ID, "Both vulnerabilities should reference the same asset")
	})
}

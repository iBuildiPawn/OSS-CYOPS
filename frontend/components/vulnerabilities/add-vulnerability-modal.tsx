"use client";

import { CheckCircle2, AlertTriangle, Shield } from "lucide-react";
import { useState, useRef, useEffect } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { VulnerabilityForm } from "@/components/vulnerabilities/vulnerability-form";
import type { ImageFile } from "@/components/vulnerabilities/vulnerability-image-upload";
import { useCreateVulnerability } from "@/hooks/use-vulnerabilities";
import { assessmentApi, vulnerabilityApi } from "@/lib/api";
import type { CreateVulnerabilityRequest } from "@/types/vulnerability";

interface AddVulnerabilityModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess?: () => void;
  assessmentId?: string | null;
}

export function AddVulnerabilityModal({
  open,
  onOpenChange,
  onSuccess,
  assessmentId,
}: AddVulnerabilityModalProps) {
  const queryClient = useQueryClient();
  const createMutation = useCreateVulnerability();
  const [error, setError] = useState<string | null>(null);
  const [proofImages, setProofImages] = useState<ImageFile[]>([]);
  const [savedFormData, setSavedFormData] =
    useState<Partial<CreateVulnerabilityRequest> | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [showCloseConfirmation, setShowCloseConfirmation] = useState(false);
  const formIsDirtyRef = useRef(false);

  // Fetch assessment details if creating from assessment
  const { data: assessmentData } = useQuery({
    queryKey: ["assessment", assessmentId],
    queryFn: () => assessmentApi.get(assessmentId!),
    enabled: !!assessmentId,
  });

  const linkToAssessmentMutation = useMutation({
    mutationFn: ({
      assessmentId,
      vulnerabilityId,
    }: {
      assessmentId: string;
      vulnerabilityId: string;
    }) =>
      assessmentApi.linkVulnerability(assessmentId, {
        vulnerability_id: vulnerabilityId,
      }),
  });

  const handleSubmit = async (data: CreateVulnerabilityRequest) => {
    try {
      setError(null);
      // Save form data for persistence
      setSavedFormData(data);

      const result = await createMutation.mutateAsync(data);

      // If coming from an assessment, link the vulnerability to it
      if (assessmentId && result.data?.id) {
        try {
          await linkToAssessmentMutation.mutateAsync({
            assessmentId,
            vulnerabilityId: result.data.id,
          });
          queryClient.invalidateQueries({
            queryKey: ["assessment", assessmentId],
          });
        } catch (linkError) {
          console.error(
            "Failed to link vulnerability to assessment:",
            linkError,
          );
        }
      }

      // Upload proof images if any
      if (proofImages.length > 0 && result.data?.id) {
        try {
          const uploadPromises = proofImages.map((imageFile) =>
            vulnerabilityApi.uploadAttachment(
              result.data!.id,
              imageFile.file,
              "PROOF",
              imageFile.description,
            ),
          );
          await Promise.all(uploadPromises);
        } catch (uploadError) {
          console.error("Failed to upload proof images:", uploadError);
          toast.warning(
            "Vulnerability created but some images failed to upload",
            {
              description:
                "You can upload images later from the vulnerability details page.",
            },
          );
        }
      }

      // Check if assets were auto-created
      if (result.auto_created_assets && result.auto_created_assets.length > 0) {
        const assetNames = result.auto_created_assets
          .map((a) => a.hostname || a.ip_address)
          .join(", ");

        const imageText =
          proofImages.length > 0
            ? ` with ${proofImages.length} proof image(s)`
            : "";
        toast.success("Vulnerability created successfully", {
          description: `Created vulnerability "${data.title}"${imageText} and ${result.auto_created_assets.length} new asset(s): ${assetNames}`,
          duration: 5000,
        });
      } else {
        const imageText =
          proofImages.length > 0
            ? ` with ${proofImages.length} proof image(s)`
            : "";
        toast.success("Vulnerability created successfully", {
          description: `"${data.title}"${imageText} has been added to the system.`,
        });
      }

      // Clear saved form data and unsaved changes flag on success
      setSavedFormData(null);
      setProofImages([]);
      setHasUnsavedChanges(false);
      formIsDirtyRef.current = false;

      // Close modal and trigger success callback
      onOpenChange(false);
      onSuccess?.();

      // Reset form state
      setError(null);
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : "Failed to create vulnerability";
      setError(errorMessage);
      toast.error("Failed to create vulnerability", {
        description: errorMessage,
      });
    }
  };

  const handleOpenChange = (newOpen: boolean) => {
    // If trying to close and there are unsaved changes, show confirmation
    if (!newOpen && hasUnsavedChanges && formIsDirtyRef.current) {
      setShowCloseConfirmation(true);
      return;
    }

    // Otherwise, allow the modal to close/open normally
    onOpenChange(newOpen);
  };

  const handleConfirmClose = () => {
    setShowCloseConfirmation(false);
    // Clear unsaved changes flag and close modal
    setHasUnsavedChanges(false);
    formIsDirtyRef.current = false;
    setSavedFormData(null);
    setProofImages([]);
    onOpenChange(false);
  };

  const handleCancelClose = () => {
    setShowCloseConfirmation(false);
  };

  const handleCancel = () => {
    // Check if there are unsaved changes
    if (hasUnsavedChanges && formIsDirtyRef.current) {
      setShowCloseConfirmation(true);
      return;
    }

    onOpenChange(false);
    setError(null);
  };

  const handleFormChange = (isDirty: boolean) => {
    formIsDirtyRef.current = isDirty;
    setHasUnsavedChanges(isDirty);
  };

  // Add browser navigation warning for unsaved changes
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (hasUnsavedChanges && formIsDirtyRef.current && open) {
        e.preventDefault();
        e.returnValue = "";
      }
    };

    window.addEventListener("beforeunload", handleBeforeUnload);

    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [hasUnsavedChanges, open]);

  const initialData =
    savedFormData ||
    (assessmentId && assessmentData?.data
      ? { source: assessmentData.data.name }
      : undefined);

  return (
    <>
      <Dialog open={open} onOpenChange={handleOpenChange}>
        <DialogContent className="max-w-5xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle className="text-2xl flex items-center gap-2">
              <Shield className="h-6 w-6" />
              Report New Vulnerability
            </DialogTitle>
            <DialogDescription>
              {assessmentId && assessmentData?.data
                ? `Creating finding for assessment: ${assessmentData.data.name}`
                : "Document a new security vulnerability in your systems"}
            </DialogDescription>
          </DialogHeader>

          {/* Success Alert */}
          {createMutation.isSuccess && (
            <Alert className="border-green-500 bg-green-50 dark:bg-green-950">
              <CheckCircle2 className="h-4 w-4 text-green-600" />
              <AlertDescription className="text-green-600">
                Vulnerability created successfully!
              </AlertDescription>
            </Alert>
          )}

          {/* Form */}
          <div className="mt-4">
            <VulnerabilityForm
              mode="create"
              initialData={initialData}
              onSubmit={handleSubmit}
              onCancel={handleCancel}
              onFormChange={handleFormChange}
              isLoading={createMutation.isPending}
              error={error}
              images={proofImages}
              onImagesChange={setProofImages}
            />
          </div>
        </DialogContent>
      </Dialog>

      {/* Unsaved Changes Confirmation Dialog */}
      <AlertDialog
        open={showCloseConfirmation}
        onOpenChange={setShowCloseConfirmation}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="flex items-center gap-2">
              <AlertTriangle className="h-5 w-5 text-amber-500" />
              Unsaved Changes
            </AlertDialogTitle>
            <AlertDialogDescription>
              You have unsaved changes in the form. If you close this dialog,
              your changes will be lost. Are you sure you want to proceed?
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleCancelClose}>
              Continue Editing
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleConfirmClose}
              className="bg-destructive hover:bg-destructive/90"
            >
              Discard Changes
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
